{"name":"Ring-logger","tagline":"Log ring requests & responses using your favorite logging backend","body":"# Ring-logger [![Circle CI](https://circleci.com/gh/nberger/ring-logger.svg?style=svg)](https://circleci.com/gh/nberger/ring-logger)\r\n\r\nRing middleware to log duration and details for every request and response.\r\n\r\nThe logging backend is pluggable. Only the [clojure/tools.logging](https://github.com/clojure/tools.logging) implementation is included.\r\n\r\nAdditional known backends:\r\n\r\n* [ring-logger-onelog](https://github.com/nberger/ring-logger-onelog)\r\n* [ring-logger-timbre](https://github.com/nberger/ring-logger-timbre)\r\n\r\n[![Clojars Project](http://clojars.org/ring-logger/latest-version.svg)](http://clojars.org/ring-logger)\r\n\r\n\r\n## Usage\r\n\r\nIn your `project.clj`, add the following dependency:\r\n\r\n```clojure\r\n    [ring-logger \"0.7.0\"]\r\n```\r\n\r\n\r\nThen, just add the middleware to your stack. It comes preconfigured with\r\nreasonable defaults, which append ANSI colorized log messages on each\r\nrequest to whatever logger is in use by [clojure/tools.logging](https://github.com/clojure/tools.logging).\r\n\r\n```clojure\r\n    (ns foo\r\n      (:require [ring.adapter.jetty     :as jetty]\r\n                [ring.logger :as logger]))\r\n\r\n    (defn my-ring-app [request]\r\n         {:status 200\r\n          :headers {\"Content-Type\" \"text/html\"}\r\n          :body \"Hello world!\"})\r\n\r\n    (jetty/run-jetty (logger/wrap-with-logger my-ring-app) {:port 8080})\r\n```\r\n\r\n\r\n### Usage with timbre\r\n\r\nCheck out [ring-logger-timbre](https://github.com/nberger/ring-logger-timbre)\r\n\r\n### Migration from ring.middleware.logger (or if you just want to use some OneLog goodies)\r\n\r\nCheck out [ring-logger-onelog](https://github.com/nberger/ring-logger-onelog), or the\r\n[0.6.x branch](https://github.com/nberger/ring-logger/tree/0.6.x)\r\n\r\n## Custom Logger Backend\r\n\r\nYou can supply a custom logger backend by passing an instance that reifies\r\nthe ring.logger/Logger protocol as :logger.\r\n\r\nExample:\r\n\r\n```clojure\r\n(wrap-with-logger my-ring-app\r\n  {:logger (reify ring.logger/Logger\r\n                  (log [level throwable msg]\r\n                    (case level\r\n                      :error\r\n                      (println \"OH NOES! We have an error!\"\r\n                               msg\r\n                               (when throwable (.getMessage throwable)))\r\n\r\n                      :trace\r\n                      nil ; let's ignore trace messages\r\n\r\n                      ; else\r\n                      (println (name level) \"-\" msg)))})\r\n```\r\n\r\nOf course this can also be done with a deftype/defrecord,\r\nsee [ring-logger-onelog](https://github.com/nberger/ring-logger-onelog) and\r\n[ring-logger-timbre](https://github.com/nberger/ring-logger-timbre) for examples.\r\n\r\n\r\n## What Gets Logged\r\n\r\nThe default setup logs:\r\n\r\n* an :info-level message when a request begins;\r\n* an :info level message when a response is generated without any server\r\nerrors (i.e. its HTTP status is < 500);\r\n* an :error level message when a response's HTTP status is >= 500;\r\n* an :error level message with a stack trace when an exception is thrown during response generation.\r\n\r\nAll messages are timestamped.\r\n\r\n\r\n## Custom messages and how to disable coloring\r\n\r\nInstead of the default messages (for request start, details, exceptions, response trace) you might want to\r\nprovide your own custom messages. That's easy by supplying implementations of the printer multimethods\r\nlike `starting`, `request-details`, `exception` and others (see `ring.logger.messages` ns for more details)\r\nand passing a `:printer` option to `wrap-with-logger`, like so:\r\n\r\n```clojure\r\n(defmethod request-details :my-printer\r\n  [{:keys [logger] :as options} req]\r\n  (trace logger (str \"detailed request details: \" req)\r\n  (info logger (str \"minimal request details: \" (select-keys req [:character-encoding\r\n                                                                  :content-length\r\n                                                                  :request-method\r\n                                                                  :uri]))))\r\n\r\n(wrap-with-logger app {:printer :my-printer})\r\n```\r\n\r\nA `:no-color` printer is provided, so to disable color:\r\n\r\n```clojure\r\n(wrap-with-logger app {:printer :no-color})\r\n```\r\n\r\n## Example Log\r\n\r\nThis is an example of logging at TRACE level with log4j:\r\n\r\n![example log capture](https://raw.githubusercontent.com/nberger/ring-logger/master/example/log-capture.png)\r\n\r\nCheck out [the example project](example) if you want to generate a similar output in your local machine.\r\n\r\n## Log the request body (for debugging)\r\n\r\nIf logging the request & response metadata is not enough when debugging and you need to take a look to\r\neach request body, then you can use `wrap-with-body-logger`:\r\n\r\n```clojure\r\n(def handler (-> app\r\n                 wrap-with-logger\r\n                 wrap-with-body-logger))\r\n```\r\n\r\n__Just be careful__: This is _inefficient_ as it has to consume the body input stream from the request\r\nand then put it again as a new input stream so your handler can also consume it as would normally do.\r\n\r\n## Logging only certain requests\r\n\r\nIf you wish to restrict logging to certain paths (or other\r\nconditions), combine ring-logger with\r\n[ring.middleware.conditional](https://github.com/pjlegato/ring.middleware.conditional), like so:\r\n\r\n```clojure\r\n(:require [ring.middleware.conditional :as c :refer  [if-url-starts-with\r\n                                                      if-url-doesnt-start-with\r\n                                                      if-url-matches\r\n                                                      if-url-doesnt-match]])\r\n\r\n(def my-ring-app\r\n   (-> handler\r\n       (if-url-starts-with \"/foo\" wrap-with-logger)\r\n\r\n        ;; Or:\r\n        ;; (c/if some-test-fn wrap-with-logger)\r\n        ;; etc.\r\n\r\n       wrap-with-other-handler))\r\n```\r\n\r\nConsult the [ring.middleware.conditional docs](https://github.com/pjlegato/ring.middleware.conditional) for full details.\r\n\r\n\r\n## Roadmap\r\n\r\n* 0.7.x\r\n    - [x] Remove onelog if we think it doesn't needs to be in ring-logger (I mean: if the same can be done by using onelog in the client app + some customization).\r\n    - [x] Leave only tools.logging implementation in ring-logger, extract timbre implementation to other library.\r\n    - [ ] Add the unique request-id as log context in ring-logger. Currently it's only supported by ring-logger-onelog\r\n    - [x] Use proper maps instead of keyword options.\r\n    - [ ] Development: Add more tests.\r\n\r\n* 0.6.x\r\n    - [x] Keep the migration path from ring.middleware.logger as smooth as possible.\r\n    - [x] Add support for tools.loggging and timbre, with the possibility to not bring not needed dependencies.\r\n    - [x] Allow for more customizations (color/no-color, customize specific log messages).\r\n    - [x] Development: Add tests, use continuous integration.\r\n\r\n## Similar projects\r\n\r\n[pjlegato/ring.middleware.logger](http://github.com/pjlegato/ring.middleware.logger): ring-logger started as a fork\r\nof ring.middleware.logger. We recommend it as a great option if you don't mind pulling a transitive dependency on onelog & log4j.\r\n\r\n## Contributing\r\n\r\nPull requests are welcome!\r\n\r\n## License\r\n\r\nCopyright (C) 2015 Nicol√°s Berger, 2012-2014 Paul Legato.\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","google":"UA-67009779-2","note":"Don't delete this file! It's used internally to help with page regeneration."}